<html>
    <head>
        <script
            type="text/javascript"
            src="../js/jquery-1.4.2.min.js">
        </script>
        <script
            type="text/javascript"
            src="../syntax_highlighter/scripts/shCore.js">
        </script>
        <script
            type="text/javascript"
            src="../syntax_highlighter/scripts/shBrushJScript.js">
        </script>
        <script
            type="text/javascript"
            src="../syntax_highlighter/scripts/shBrushPhp.js">
        </script>
        <script
            type="text/javascript"
            src="../syntax_highlighter/scripts/shBrushXml.js">
        </script>
        <link
            href="../syntax_highlighter/styles/shCore.css" rel="stylesheet"
            type="text/css"
        />
        <link
            href="../syntax_highlighter/styles/shCoreEclipse.css"
            rel="stylesheet" type="text/css"
        />
        <link
            href="../syntax_highlighter/styles/shThemeWordpress.css"
            rel="stylesheet" type="text/css"
        />
    </head>
    <body>
        <pre class="brush: php">&lt;?php
/**
 * Syndication API SDK
 *
 * @package Syndication\SDK\PHP
 */ 

/**
 * SyndicationResponse 
 * 
 * @author Dan Narkiewicz &lt;dnarkiewicz@ctacorp.com&gt; 
 * @package Syndication\SDK\PHP
 */
class SyndicationResponse
{

  /**
   * http-response content-type 
   * 
   * @var string
   * @access public
   */
  var $format  = null;
  /**
   * http-reponse status 
   * 
   * @var mixed
   * @access public
   */
  var $status  = null;
  /**
   * list of message arrays [ {errorMessage:string, errorDetail:string, errorCode:int}, ... ] 
   * 
   * @var array
   * @access public
   */
  var $message = array();
  /**
   * list of result data 
   * 
   * @var array
   * @access public
   */
  var $results = array();
  /**
   * success of requested operation, not of http-request
   * 
   * @var boolean
   * @access public
   */
  var $success = null;

  /**
   * Constructor for Response 
   * 
   * @access protected
   * 
   * @return self
   */
  function __construct()
  {
    $this-&gt;format  = null;
    $this-&gt;status  = null;
    $this-&gt;message = array();
    $this-&gt;results = array();
    $this-&gt;success = null;
  }
}



/**
 * Syndication 
 * 
 * @author Dan Narkiewicz &lt;dnarkiewicz@ctacorp.com&gt; 
 * @package Syndication\SDK\PHP
 */
class Syndication
{
    /**
     * api setting for outgoing calls
     *
     * @var array
     * @array format
     *     url      : string
     *     tinu_url : string
     *     cms_url  : string
     *     cms_id   : string
     *     api_key  : string
     *     timeout  : integer
     *
     * @access public
     */
    var $api = array(
        'url'      =&gt; '',
        'tiny_url' =&gt; '',
        'cms_url'  =&gt; '',
        'cms_id'   =&gt; '',
        'api_key'  =&gt; '',
        'timeout'  =&gt; '',
    );

    /**
     * format for server error messages      
     * 
     * @var array 
     * @array format
     *     errorMessage : string
     *     errorDetail  : string
     *     errorCode    : string
     *
     * @access public
     */
    var $empty_response_message = array(
        'errorMessage' =&gt; null,
        'errorDetail'  =&gt; null,
        'errorCode'    =&gt; null,
    );
    
    /**
     * Constructor for Syndication interface
     * 
     * @param mixed $api if array, settings. if string, config file path. 
     * @access protected
     * 
     * @return void
     */
    function __construct ( $api=null )
    {
        if ( is_array($api) )
        {
            $this-&gt;api = array_merge($this-&gt;api,$api);
        } else {
            /// if api is an array ( merge with defaults );
            /// if api is string ( assume file on filesystem - read and try and guess format )
            $this-&gt;api = array(
                'url'      =&gt; 'http://ctacdev.com:8090/Syndication/api/v1/resources',
                'tiny_url' =&gt; 'http://ctacdev.com:8082/',
                'cms_url'  =&gt; 'http://ctacdev.com:8090/CMS_Manager/api/v1/resources',
                'cms_id'   =&gt; 'drupal_cms_1',
                'api_key'  =&gt; 'TEST_CMS1', // 'TEST_CMS2'
                'timeout'  =&gt; 60
            );
        }
    }

    /// API FUNCTIONS

    /**
     * Gets a list of all MediaType Names 
     * 
     * @access public
     * 
     * @return SyndicationResponse -&gt;results[]
     *      string
     */
    function getAllMediaTypes ()
    {
        try
        {
            $result = $this-&gt;apiCall('get',&quot;{$this-&gt;api['url']}/mediaTypes.json&quot;);
            return $this-&gt;createResponse($result,'get All MediaTypes');
        } catch ( Exception $e ) {
            return $this-&gt;createResponse($e,'API Call');
        }
    }

    /**
     * Gets a list of Organizations
     * 
     * @param array $params options
     *      max    : int
     *      offset : int
     *      sort   : string
     *      order  : string
     * 
     * @access public
     * @return SyndicationResponse -&gt;results[]
     *      id   : int 
     *      name : string
     *      abv  : string
     *      url  : string 
     */
    function getAllOrganizations ( $params=array() )
    {
        try
        {
            $result = $this-&gt;apiCall('get',&quot;{$this-&gt;api['url']}/organizations.json&quot;,$params);
            return $this-&gt;createResponse($result,'get All Organizations');
        } catch ( Exception $e ) {
            return $this-&gt;createResponse($e,'API Call');
        }
    }
    /**
     * Gets a single Organization
     * 
     * @param mixed $id Numeric Id of the organization 
     * 
     * @access public
     * @return SyndicationResponse -&gt;results[]
     *      id   : int 
     *      name : string
     *      abv  : string
     *      url  : string 
     */
    function getOrganizationByOrganizationId ( $id )
    {
        try
        {
            $result = $this-&gt;apiCall('get',&quot;{$this-&gt;api['url']}/organizations/{$id}.json&quot;);
            return $this-&gt;createResponse($result,'get Organization','Id');
        } catch ( Exception $e ) {
            return $this-&gt;createResponse($e,'API Call');
        }
    }

    /**
     * Gets a list of all Campaigns 
     * 
     * @param array $params options 
     *      max    : int
     *      offset : int
     *      sort   : string
     *      order  : string
     *  
     * @access public
     * @return SyndicationResponse -&gt;results[]
     *      id           : int
     *      name         : string
     *      description  : string
     *      startDate    : date
     *      endDate      : date
     *      organization : organization  
     */
    function getAllCampaigns ( $params=array() )
    {
        try
        {
            $result = $this-&gt;apiCall('get',&quot;{$this-&gt;api['url']}/campaigns.json&quot;,$params);
            return $this-&gt;createResponse($result,'get All Campaigns');
        } catch ( Exception $e ) {
            return $this-&gt;createResponse($e,'API Call');
        }
    }
    /**
     * Gets a single Campaign
     * 
     * @param mixed $id Numeric Id of the campaign 
     *  
     * @access public
     * @return SyndicationResponse -&gt;results[]
     *      id           : int
     *      name         : string
     *      description  : string
     *      startDate    : date
     *      endDate      : date
     *      organization : organization  
     */
    function getCampaignByCampaignId ( $id )
    {
        try
        {
            $result = $this-&gt;apiCall('get',&quot;{$this-&gt;api['url']}/campaigns/{$id}.json&quot;);
            return $this-&gt;createResponse($result,'get Campaign','Id');
        } catch ( Exception $e ) {
            return $this-&gt;createResponse($e,'API Call');
        }
    }

    /**
     * Gets a list of all Languages
     *
     * @param array $params options 
     *      max    : int
     *      offset : int
     *      sort   : string
     *      order  : string
     *  
     * @access public
     * @return SyndicationResponse -&gt;results[]
     *      id    : int
     *      name  : string
     *      value : string
     */
    function getAllLanguages ( $params=array() )
    {
        try
        {
            $result = $this-&gt;apiCall('get',&quot;{$this-&gt;api['url']}/languages.json&quot;,$params);
            return $this-&gt;createResponse($result,'get All Languages');
        } catch ( Exception $e ) {
            return $this-&gt;createResponse($e,'API Call');
        }
    }
    /**
     * Gets a single Language
     * 
     * @param mixed $id Numeric Id of the language 
     *  
     * @access public
     * @return SyndicationResponse -&gt;results[]
     *      id    : int
     *      name  : string
     *      value : string
     */
    function getLanguageByLanguageId ( $id )
    {
        try
        {
            $result = $this-&gt;apiCall('get',&quot;{$this-&gt;api['url']}/languages/{$id}.json&quot;);
            return $this-&gt;createResponse($result,'get Language','Id');
        } catch ( Exception $e ) {
            return $this-&gt;createResponse($e,'API Call');
        }
    }

    /**
     * Gets a list of all Tags 
     * @param array $params options
     *      sort  : string
     *      order : string
     *  
     * @access public
     * @return SyndicationResponse -&gt;results[]
     *      id   : int
     *      name : string
     */
    function getAllTags ( $params )
    {
        try
        {
            $result = $this-&gt;apiCall('get',&quot;{$this-&gt;api['url']}/tags.json&quot;,$params);
            return $this-&gt;createResponse($result,'get All Tags');
        } catch ( Exception $e ) {
            return $this-&gt;createResponse($e,'API Call');
        }
    }
    /**
     * Gets a single Tag
     * 
     * @param mixed $id Numeric Id of the tag 
     *  
     * @access public
     * @return SyndicationResponse -&gt;results[]
     *      id   : int
     *      name : string
     */
    function getTagByTagId ( $id )
    {
        try
        {
            $result = $this-&gt;apiCall('get',&quot;{$this-&gt;api['url']}/tags/{$id}.json&quot;);
            return $this-&gt;createResponse($result,'get Tag','Id');
        } catch ( Exception $e ) {
            return $this-&gt;createResponse($e,'API Call');
        }
    }
    /**
     * Gets a list of Tags related to a specific Tag
     * 
     * @param mixed $id Numeric Id of the tag 
     *  
     * @access public
     * @return SyndicationResponse -&gt;results[]
     *      id   : int
     *      name : string
     */
    function getRelatedTagsByTagId ( $id )
    {
        try
        {
            $result = $this-&gt;apiCall('get',&quot;{$this-&gt;api['url']}/tags/{$id}/related.json&quot;);
            return $this-&gt;createResponse($result,'get Related Tags','Id');
        } catch ( Exception $e ) {
            return $this-&gt;createResponse($e,'API Call');
        }
    }
    
    /**
     * Gets a list of Media MetaData.
     * Makes a different API call depending on $query. 
     * 
     * @param mixed $query if string: all-column text search. if array: per-column search params 
     *      max                      : int
     *      offset                   : int
     *      sort                     : string 
     *      order                    : string 
     *      mediaType                : string
     *      nameContains             : string
     *      descriptionContains      : string
     *      licenseInfoContains      : string
     *      sourceUri                : string
     *      sourceUriContains        : string
     *      dateAuthored             : string
     *      authoredSinceDate        : string
     *      authoredBeforeDate       : string
     *      authoredInRange          : string
     *      updatedSinceDate         : string
     *      updatedBeforeDate        : string
     *      updatedInRange           : int
     *      languageName             : string
     *      languageValue            : string
     *      hash                     : string
     *      hashContains             : string
     *      organizationId           : int
     *      organizationName         : string
     *      organizationNameContains : string
     *      organizationAbv          : string
     *      organizationAbvContains  : string
     *      tagIds                   : csv_string
     *      restrictToSet            : csv_string
     * 
     * @access public
     * @return SyndicationResponse -&gt;results[]
     *      id           : int
     *      name         : string
     *      description  : string
     *      licenseInfo  : string
     *      sourceUri    : string
     *      dateAuthored : date(rfc3339)
     *      dateUpdated  : date(rfc3339)
     *      language     : language
     *      active       : boolean
     *      externalGuid : string
     *      hash         : string
     *      organization : organization
     */
    function searchMedia( $query )
    {
        try
        {
            if ( is_array($query) )
            {
              $result = $this-&gt;apiCall('get',&quot;{$this-&gt;api['url']}/media.json&quot;,$query);
            } else {  
              $params = array( 'q' =&gt; $query );
              $result = $this-&gt;apiCall('get',&quot;{$this-&gt;api['url']}.json&quot;,$params,'json');
            }
            return $this-&gt;createResponse($result,'search Resources','Search Criteria');
        } catch ( Exception $e ) {
            return $this-&gt;createResponse($e,'API Call');
        }
    }
    /**
     * Gets a single Media MetaData
     * 
     * @param mixed $id Numeric Id of the MediaItem 
     * 
     * @access public
     * @return SyndicationResponse -&gt;results[]
     *      id           : int
     *      name         : string
     *      description  : string
     *      licenseInfo  : string
     *      sourceUri    : string
     *      dateAuthored : date(rfc3339)
     *      dateUpdated  : date(rfc3339)
     *      language     : language
     *      active       : boolean
     *      externalGuid : string
     *      hash         : string
     *      organization : organization
     */
    function getMediaMetadataByMediaId ( $id )
    {
        try
        {
            $result = $this-&gt;apiCall('get',&quot;{$this-&gt;api['url']}/media/{$id}.json&quot;);
            return $this-&gt;createResponse($result,'get MetaData','Id');
        } catch ( Exception $e ) {
            return $this-&gt;createResponse($e,'API Call');
        }
    }
    /**
     * Gets a single Media MetaData
     * 
     * @param string $source_url Url of the media source 
     * 
     * @access public
     * @return SyndicationResponse -&gt;results[]
     *      id           : int
     *      name         : string
     *      description  : string
     *      licenseInfo  : string
     *      sourceUri    : string
     *      dateAuthored : date(rfc3339)
     *      dateUpdated  : date(rfc3339)
     *      language     : language
     *      active       : boolean
     *      externalGuid : string
     *      hash         : string
     *      organization : organization
     */
    function getMediaMetadataByMediaUrl ( $source_url )
    {
        try
        {
            $params = array( 'sourceUri' =&gt; $source_url );
            $result = $this-&gt;apiCall('get',&quot;{$this-&gt;api['url']}/media.json&quot;,$params);
            return $this-&gt;createResponse($result,'get MetaData','Url');
        } catch ( Exception $e ) {
            return $this-&gt;createResponse($e,'API Call');
        }
    }
    /**
     * Gets a list of Media MetaData
     * 
     * @param mixed $id Numeric Id of a Tag 
     * 
     * @access public
     * @return SyndicationResponse -&gt;results[]
     *      id           : int
     *      name         : string
     *      description  : string
     *      licenseInfo  : string
     *      sourceUri    : string
     *      dateAuthored : date(rfc3339)
     *      dateUpdated  : date(rfc3339)
     *      language     : language
     *      active       : boolean
     *      externalGuid : string
     *      hash         : string
     *      organization : organization
     */
    function getMediaMetadataByTagId ( $id )
    {
        try
        {
            $result = $this-&gt;apiCall('get',&quot;{$this-&gt;api['url']}/tags/{$id}/media.json&quot;);
            return $this-&gt;createResponse($result,'get MetaData','Tag Id');
        } catch ( Exception $e ) {
            return $this-&gt;createResponse($e,'API Call');
        }
    }

    
    /**
     * Publish a new piece of Media content 
     * 
     * @param mixed $params options 
     *      name         : string 
     *      sourceUri    : string 
     *      dateAuthored : date 
     *      dateUpdated  : date 
     *      language     : string
     *      organization : string 
     *
     * @access public
     * @return SyndicationResponse -&gt;results[]
     *      id           : int
     *      name         : string
     *      description  : string
     *      licenseInfo  : string
     *      sourceUri    : string
     *      dateAuthored : date(rfc3339)
     *      dateUpdated  : date(rfc3339)
     *      language     : language
     *      active       : boolean
     *      externalGuid : string
     *      hash         : string
     *      organization : organization
     */
    function publish ( $params )
    {
        /// syndication will always return metadata for one content item
        /// if publishing a collection, we get single collection item, which contains a list of any sub-items also generated
        try
        {
            $type_path = $params['mt'];
            // dirty pluralization
            if( !in_array($type_path,array('SocialMedia','Audio')) ) { $type_path .= 's'; }
            $type_path{0} = strtolower($type_path{0});
            //$query = http_build_query($params);
            $result = $this-&gt;apiCall('post',&quot;{$this-&gt;api['url']}/media/$type_path&quot;,$params,'json');
            return $this-&gt;createResponse($result,'Publish');
        } catch ( Exception $e ) {
            return $this-&gt;createResponse($e,'API Call');
        }
    }
    /**
     * UnPublish a piece of Media content by Id 
     * 
     * @param mixed $id id Numeric Id of a Media item 
     * @access public
     * 
     * @return SyndicationResponse -&gt;results[]
     *      media metatdata ?
     */
    function unPublishByMediaId ( $id )
    {
        /// syndication will always return metadata for one content item
        /// if publishing a collection, we get collection item, which contains list of any sub-items also generated
        try
        {
            $result = $this-&gt;apiCall('delete',&quot;{$this-&gt;api['url']}/media/{$id}&quot;);
            return $this-&gt;createResponse($result,'Un-Publish','Id');
        } catch ( Exception $e ) {
            return $this-&gt;createResponse($e,'API Call');
        }
    }

    /**
     * Subscribe to piece of Media content by Id 
     * 
     * @param mixed $id id Numeric Id of a Media item 
     * @access public
     * 
     * @return SyndicationResponse -&gt;results[]
     *      id           : int
     *      name         : string
     *      description  : string
     *      licenseInfo  : string
     *      sourceUri    : string
     *      dateAuthored : date(rfc3339)
     *      dateUpdated  : date(rfc3339)
     *      language     : language
     *      active       : boolean
     *      externalGuid : string
     *      hash         : string
     *      organization : organization
     */
    function subscribeByMediaId ( $id )
    {
        try
        {
            $result = $this-&gt;apiCall('post',&quot;{$this-&gt;api['cms_url']}/subscriptions/{$id}&quot;,array(),'json');
            return $this-&gt;createResponse($result,'Subscribe','Id');
        } catch ( Exception $e ) {
            return $this-&gt;createResponse($e,'API Call');
        }
    }
    /**
     * UnSubscribe to piece of Media content by Id 
     * 
     * @param mixed $id id Numeric Id of a Media item 
     * 
     * @access public
     * @return SyndicationResponse -&gt;results[]
     *      id           : int
     *      name         : string
     *      description  : string
     *      licenseInfo  : string
     *      sourceUri    : string
     *      dateAuthored : date(rfc3339)
     *      dateUpdated  : date(rfc3339)
     *      language     : language
     *      active       : boolean
     *      externalGuid : string
     *      hash         : string
     *      organization : organization
     */
    function unSubscribeByMediaId ( $id )
    {
        try
        {
            $result = $this-&gt;apiCall('delete',&quot;{$this-&gt;api['cms_url']}/subscriptions/{$id}&quot;,array(),'json');
            return $this-&gt;createResponse($result,'Un-Subscribe','Id');
        } catch ( Exception $e ) {
            return $this-&gt;createResponse($e,'API Call');
        }
    }
    /**
     * Gets a single CMS's MetaData 
     * 
     * @param mixed $id Numeric Id of the CMS 
     * 
     * @access public
     * @return SyndicationResponse -&gt;results[]
     *      cms metadata
     */
    function getCmsMetadataByCmsId ()
    {
        try
        {
            $result = $this-&gt;apiCall('get',&quot;{$this-&gt;api['cms_url']}/cms/{$this-&gt;api['cms_id']}&quot;,array(),'json');
            return $this-&gt;createResponse($result,'get My CMS Information');
        } catch ( Exception $e ) {
            return $this-&gt;createResponse($e,'API Call');
        }
    }
    /**
     * Gets all subscriptions belonging to the CMS identified by APIKEY
     * 
     * @access public
     * @return SyndicationResponse -&gt;results[]
     *      subscription metadata
     */
    function getAllMySubscriptions ()
    {
        try
        {
            $result = $this-&gt;apiCall('get',&quot;{$this-&gt;api['cms_url']}/subscriptions.json&quot;,array(),'json');
            return $this-&gt;createResponse($result,'get My Subscriptions');
        } catch ( Exception $e ) {
            return $this-&gt;createResponse($e,'API Call');
        }
    }
    /**
     * Gets a single Subscription
     * 
     * @param mixed $id Numeric Id of the Subscription 
     * 
     * @access public 
     * @return SyndicationResponse -&gt;results[]
     *      subscription metadata
     */
    function getSubscriptionBySubscriptionId ( $id )
    {
        try
        {
            $result = $this-&gt;apiCall('get',&quot;{$this-&gt;api['cms_url']}/subscriptions/{$id}&quot;,array(),'json');
            return $this-&gt;createResponse($result,'get My Subscriptions');
        } catch ( Exception $e ) {
            return $this-&gt;createResponse($e,'API Call');
        }
    }
    /**
     * Gets the source content of a single Media item
     * 
     * @param mixed $id Numeric Id of the MediaItem 
     * 
     * @access public 
     * @return SyndicationResponse -&gt;results[]
     *      mixed : string or base64 encoded data
     */
    function getMediaContentByMediaId ( $id )
    {
        try
        {
            $result = $this-&gt;apiCall('get',&quot;{$this-&gt;api['url']}/media/{$id}/content&quot;);
            return $this-&gt;createResponse($result,'get Content','Id');
        } catch ( Exception $e ) {
            return $this-&gt;createResponse($e,'API Call');
        }
    }
    /**
     * Gets a preview image of a single Media item. Allows custom size configurations.
     * 
     * @param mixed $id Numeric Id of the Meda Item   
     * @param mixed $params options
     *      id         : int
     *      imageFloat : string
     * 
     * @access public 
     * @return SyndicationResponse -&gt;results[]
     *      base64 encoded jpg
     */
    function getMediaPreviewByMediaId ( $id, $params=array() )
    {
        try
        {
            $result = $this-&gt;apiCall('get',&quot;{$this-&gt;api['url']}/media/{$id}/preview.jpg&quot;);
            return $this-&gt;createResponse($result,'get Content Preview','Id');
        } catch ( Exception $e ) {
            return $this-&gt;createResponse($e,'API Call');
        }
    }
    /**
     * Gets a fixed size thumbnail image of a single Media item. Allows custom margin configuration.
     * 
     * @param mixed $id Numeric Id of MediaItem
     * @param mixed $params options
     *      imageFloat  : string
     *      imageMargin : css string (int,int,int,int)
     * 
     * @access public 
     * @return SyndicationResponse -&gt;results[]
     *      base64 encoded jpg
     */
    function getMediaThumbnailByMediaId ( $id, $params=array() )
    {
        try
        {
            $result = $this-&gt;apiCall('get',&quot;{$this-&gt;api['url']}/media/{$id}/thumbnail.jpg&quot;);
            return $this-&gt;createResponse($result,'get Content Thumbnail','Id');
        } catch ( Exception $e ) {
            return $this-&gt;createResponse($e,'API Call');
        }
    }
    /**
     * Gets the content belonging to a given MediaItem for embedding. Supports HTML, JSON and XML responses based on request format
     *
     * @param mixed $id Numeric Id of MediaItem
     * @param string $format Desired return format of embedded html
     *
     * @access public 
     * @return SyndicationResponse -&gt;results[]
     *      string (html,json,xml)
     */
    function getMediaEmbeddedHtmlByMediaId ( $id, $format='html' )
    {
        try
        {
            if ( !in_array( $format, array('json','html','xml') ) ) { $format='html'; }
            $result = $this-&gt;apiCall('get',&quot;{$this-&gt;api['url']}/media/{$id}/embed.{$format}&quot;);
            return $this-&gt;createResponse($result,'get Embedded Html','Id');
        } catch ( Exception $e ) {
            return $this-&gt;createResponse($e,'API Call');
        }
    }
    /**
     * Get javascript code used to embed this MediaItem.
     *
     * @param mixed $id Numeric Id of MediaItem
     *
     * @access public 
     * @return SyndicationResponse -&gt;results[]
     *      html
     */
    function getMediaJavascriptEmbedTagByMediaId ( $id )
    {
        try
        {
            $result = $this-&gt;apiCall('get',&quot;{$this-&gt;api['url']}/media/{$id}/javascriptEmbedTag.html&quot;);
            return $this-&gt;createResponse($result,'get Snippet Code','Id');
        } catch ( Exception $e ) {
            return $this-&gt;createResponse($e,'API Call');
        }
    }
    /**
     * Gets Youtube metadata for this MediaItem.
     *
     * @param mixed $id Numeric Id of MediaItem
     *
     * @access public 
     * @return SyndicationResponse -&gt;results[]
     *      youtube metatdata
     */
    function getMediaYoutubeMetadataByMediaId ( $id )
    {
        try
        {
            $result = $this-&gt;apiCall('get',&quot;{$this-&gt;api['url']}/media/{$id}/youtubeMedaData.json&quot;);
            return $this-&gt;createResponse($result,'get YouTube MetaData','Id');
        } catch ( Exception $e ) {
            return $this-&gt;createResponse($e,'API Call');
        }
    }
    /**
     * Gets the iframe content belonging to a given MediaItem for embedding. Name is placed into the iframe's html.
     *
     * @param mixed $id Numeric Id of MediaItem
     * @param mixed $params options
     *      width  : int
     *      height : int
     *      name   : string
     *
     * @access public 
     * @return SyndicationResponse -&gt;results[]
     *     html 
     */
    function getMediaIframeEmbeddedTagByMediaId ( $id, $params=array() )
    {
        try
        {
            $result = $this-&gt;apiCall('get',&quot;{$this-&gt;api['url']}/media/{$id}/iframeEmbeddedTag&quot;,$params);
            return $this-&gt;createResponse($result,'get Embedded IFrame','Id');
        } catch ( Exception $e ) {
            return $this-&gt;createResponse($e,'API Call');
        }
    }


    /// INTERNAL FUNCTIONS

    /**
     * Parse a URL string into array. 
     * Based on RFC3986 'URI Generic Syntax' regex. Added 'Format' as the last dot expression of the path. Does not include character encoding restrictions.
     * 
     * @param mixed $url url
     *
     * @access public
     * @return array keys 
     *      scheme
     *      userinfo
     *      host
     *      path
     *      format
     *      query
     *      fragment 
     */
    function parseUrl($url)
    {
        $simple_url = &quot;/^(?:(?P&lt;scheme&gt;[^:\/?#]+):\/\/)(?:(?P&lt;userinfo&gt;[^\/@]*)@)?(?P&lt;host&gt;[^\/?#]*)(?P&lt;path&gt;[^?#]*?(?:\.(?P&lt;format&gt;[^\.?#]*))?)?(?:\?(?P&lt;query&gt;[^#]*))?(?:#(?P&lt;fragment&gt;.*))?$/i&quot;;
        $url_parts  = array();
        preg_match($simple_url, $url, $url_parts);
        return $url_parts;
    }
    /**
     * Guess response format directly from the url. 
     * Checks the path for a known file extension. Default for no file extension is 'raw'. Basic image types combined into 'image'.
     * 
     * @param mixed $url url 
     * @access public
     * 
     * @return string response format 
     */
    function guessFormatFromUrl ($url)
    {
        $url_parts = $this-&gt;parseUrl($url);
        if ( empty($url_parts) )
        {
            return 'raw';
        }
        $format = !empty($url_parts['format'])?$url_parts['format']:'raw';
        if ( in_array($format,array('jpg','jpeg','png','gif')) ) { $format = 'image'; }
        return $format;
    }
    /**
     * Guess response format from response headers. Defaults to 'raw'. Checks Content-Type header. If no content-type header and first character of body is '{', assume 'json'. 
     * 
     * @param mixed $response response 
     * @access public
     * 
     * @return string format
     */
    function guessFormatFromResponse ($response)
    {
        if ( stripos($response['content_type'],'json')       !== false ) { return 'json';  }
        if ( stripos($response['content_type'],'image')      !== false ) { return 'image'; }
        if ( stripos($response['content_type'],'html')       !== false ) { return 'html';  }
        if ( stripos($response['content_type'],'text')       !== false ) { return 'text';  }
        if ( stripos($response['content_type'],'javascript') !== false ) { return 'js';    }
        /// last ditch effort to guess json
        if ( is_string($response['content']) &amp;&amp; $response['content']{0} == '{' ) { return 'json';  }
        return 'raw';
    }
    /**
     * Decode Http Status code into string
     * 
     * @param mixed $status status 
     * @access public
     * 
     * @return string status message
     */
    function httpStatusMessage ( $status )
    {
        # rfc2616-sec10
        $messages = array(
            // [Informational 1xx]
            100=&gt;'100 Continue',
            101=&gt;'101 Switching Protocols',
            // [Successful 2xx]
            200=&gt;'200 OK',
            201=&gt;'201 Created',
            202=&gt;'202 Accepted',
            203=&gt;'203 Non-Authoritative Information',
            204=&gt;'204 No Content',
            205=&gt;'205 Reset Content',
            206=&gt;'206 Partial Content',
            // [Redirection 3xx]
            300=&gt;'300 Multiple Choices',
            301=&gt;'301 Moved Permanently',
            302=&gt;'302 Found',
            303=&gt;'303 See Other',
            304=&gt;'304 Not Modified',
            305=&gt;'305 Use Proxy',
            306=&gt;'306 (Unused)',
            307=&gt;'307 Temporary Redirect',
            // [Client Error 4xx]
            400=&gt;'400 Bad Request',
            401=&gt;'401 Unauthorized',
            402=&gt;'402 Payment Required',
            403=&gt;'403 Forbidden',
            404=&gt;'404 Not Found',
            405=&gt;'405 Method Not Allowed',
            406=&gt;'406 Not Acceptable',
            407=&gt;'407 Proxy Authentication Required',
            408=&gt;'408 Request Timeout',
            409=&gt;'409 Conflict',
            410=&gt;'410 Gone',
            411=&gt;'411 Length Required',
            412=&gt;'412 Precondition Failed',
            413=&gt;'413 Request Entity Too Large',
            414=&gt;'414 Request-URI Too Long',
            415=&gt;'415 Unsupported Media Type',
            416=&gt;'416 Requested Range Not Satisfiable',
            417=&gt;'417 Expectation Failed',
            // [Server Error 5xx]
            500=&gt;'500 Internal Server Error',
            501=&gt;'501 Not Implemented',
            502=&gt;'502 Bad Gateway',
            503=&gt;'503 Service Unavailable',
            504=&gt;'504 Gateway Timeout',
            505=&gt;'505 HTTP Version Not Supported'
        );
        return isset($messages[$status])? $messages[$status] : null;
    }

    /**
     * Wraps curl response or exception into a common SyndicationResponse Object. 
     * 
     * @param mixed $from Curl Response or Exception 
     * @param string $action Devloper friendly description of what triggered response
     * @param mixed $key API Key used to connect 
     *
     * @access public
     * @return SyndicationResponse object
     *      -&gt;format  : string  http response format
     *      -&gt;status  : string  http response status
     *      -&gt;message : array   developer friendly error messages
     *      -&gt;results : array
     *      -&gt;success : boolean
     */
    function createResponse ( $from, $action=&quot;Process Request&quot;, $key=null )
    {
        /// an exception was thrown
        if ( is_subclass_of($from,'Exception') )
        {
            $response = $this-&gt;empty_response;
            $response['success']           = false;
            $response['meta']['status']    = $from-&gt;getCode();
            $response['meta']['format']    = 'Exception';
            $response['meta']['message'][] = array(
                'errorCode'    =&gt; $from-&gt;getCode(),
                'errorMessage' =&gt; $from-&gt;getMessage(),
                'errorDetail'  =&gt; &quot;{$action} Exception&quot;
            );
            return $response;

            /// response from server
        } else if ( is_array($from)
            &amp;&amp; !empty($from['http'])
            &amp;&amp; !empty($from['format']) )
        {
            $status = intval($from['http']['http_code']);
            if ( $from['format']=='json' )
            {
                /// we require a [meta] and [results] from any json response
                if ( is_array($from['content']) &amp;&amp; isset($from['content']['meta']) &amp;&amp; isset($from['content']['results']) )
                {
                    $response = $from['content'];
                } else {
                    $response = $this-&gt;empty_response;
                    $response['results'] = array($from['content']);
                }

                $response['meta']['status'] = $status;
                $response['meta']['format'] = 'json';

                if        ( $status&gt;=200 &amp;&amp; $status&lt;=299 )
                {
                    $response['success'] = true;
                } else if ( $status&gt;=400 &amp;&amp; $status&lt;=499 ) {
                    if ( $status == 401 ) {
                        $errorDetail = &quot;Unauthorized. Check API Key.&quot;;
                    } else if ( $status == 404 &amp;&amp; !empty($key) ) {
                        $errorDetail = &quot;Failed to {$action}. {$key} Not Found.&quot;;
                    } else {
                        $errorDetail = &quot;Failed to {$action}. Request Error.&quot;;
                    }
                    $response['success']  = false;
                    $response['meta']['message'][]  = array(
                        'errorCode'    =&gt; $status,
                        'errorMessage' =&gt; $this-&gt;httpStatusMessage($status),
                        'errorDetail'  =&gt; $errorDetail
                    );
                } else if ( $status&gt;=500 &amp;&amp; $status&lt;=599 ) {
                    $response['success']  = false;
                    $response['meta']['message'][]  = array(
                        'errorCode'    =&gt; $status,
                        'errorMessage' =&gt; $this-&gt;httpStatusMessage($status),
                        'errorDetail'  =&gt; &quot;Failed to {$action}. Server Error.&quot;
                    );
                }
                return $response;
            } else if ( $from['format']=='image' ) {
                $response = $this-&gt;empty_response;
                $response['success'] = true;
                $response['meta']['status'] = $status;
                $response['meta']['format'] = 'image';
                /// imagecreatefromstring ?
                $response['results'] = $from['content'];
                return $response;
            } else {
                $response = $this-&gt;empty_response;
                $response['success'] = true;
                $response['meta']['status'] = $status;
                $response['meta']['format'] = $from['format'];
                /// filter html ?
                $response['results'] = $from['content'];
                return $response;
            }
        }
        /// we got something weird - can't deal with this
        $response = $this-&gt;empty_response;
        $response['success'] = false;
        $status = null;
        if ( is_array($from) &amp;&amp; !empty($from['http']) &amp;&amp; isset($from['http']['http_status']) )
        {
            $status = $from['http']['http_status'];
        }
        $response['meta']['message'][] = array(
            'errorCode'    =&gt; $status,
            'errorMessage' =&gt; $this-&gt;httpStatusMessage($status),
            'errorDetail'  =&gt; &quot;Unknown response from Server.&quot;
        );
        $response['results'] = $from;
        return $response;
    }

    /**
     * Makes http request to a Syndication Service 
     * 
     * @param mixed $http_method http method 
     * @param mixed $url url 
     * @param array $params query params 
     * @param mixed $response_format expected response format 
     *
     * @access public
     * @return array format
     *      http    : array   curl info about request and response
     *      content : string  response body
     *      format  : string  response format
     */
    function apiCall ( $http_method, $url, $params=array(), $response_format=null )
    {
        if ( empty($response_format) )
        {
            $response_format = $this-&gt;guessFormatFromUrl($url);
        }

        /// our request format type
        $request_headers = array(
            //'Content-Type: text/xml; charset=UTF-8',
            'Content-Type: application/x-www-form-urlencoded',
            'Date: '.gmdate('D, d M Y H:i:s', time()).' GMT'
        );

        /// ask for a specific format type of response
        if ( !empty($response_format) )
        {
            switch( $response_format )
            {
                case 'html':
                    $request_headers[] = 'Accept: text/html; charset=UTF-8';
                    break;
                case 'json':
                    $request_headers[] = 'Accept: application/json; charset=UTF-8';
                    break;
                case 'js':
                    $request_headers[] = 'Accept: application/javascript; charset=UTF-8';
                    break;
                case 'text':
                    $request_headers[] = 'Accept: text/plain; charset=UTF-8';
                    break;
                case 'image':
                    $request_headers[] = 'Accept: image/*;';
                    break;
            }
        }
        
        $apikey = $this-&gt;apiGenerateKey( $http_method, $url, $params, $request_headers );
        $request_headers[] = &quot;Authentication: syndication_api_key {$apiKey}&quot;;

        $curl = $this-&gt;apiBuildCurlRequest( $http_method, $url, $params, $request_headers, $response_format ); 

        $content = curl_exec($curl);
        $http    = curl_getinfo($curl);

        if ($content === false)
        {
            curl_close($curl);
            throw new Exception('Syndication: No Response: '. $http['http_code'], $http['http_code'] );
            return null;
        }
        curl_close($curl);

        if ( empty($response_format) )
        {
            $response_format = $this-&gt;guessFormatFromResponse($http);
        }

        $api_response = array(
            'http'    =&gt; $http,
            'content' =&gt; $content,
            'format'  =&gt; $response_format
        );

        /// test result content-type for JSON / HTML / IMG
        /// json needs to be decoded
        /// html stay as text
        /// images need to be: base64_encoded string or image resource
        if ( $response_format=='image' )
        {
            // as GD handle ?
            // $api_response['content'] = imagecreatefromstring($content);
        } else if ( $response_format=='text' ) {
            // nuthin
        } else if ( $response_format=='html' ) {
            // any html cleaning ?
        } else if ( $response_format=='js'   ) {
            // any xss cleaning ?
        } else if ( $response_format=='json' ) {
            $decoded = json_decode($content,true);
            if ( isset($decoded['results']) )
            {
                if ( empty($decoded['results']) || count($decoded['results'])==1 &amp;&amp; empty($decoded['results'][0]) )
                {
                    $decoded['results'] = array();
                }
            }
            $api_response['content'] = $decoded;
        }
        return $api_response;
    }

    /**
     * Builds Curl Object capable of talking to Syndication Service
     * 
     * @param string $http_method http request method 
     * @param string $url url 
     * @param array $params query params 
     * @param array $headers headers 
     * @param string $response_format expected http response format 
     *
     * @access public
     * @return curl resouce handle
     */
    function apiBuildCurlRequest( $http_method, $url, $params=array(), $headers=array(), $response_format='' )
    {
        $http_params = http_build_query( $params, '', '&amp;' );
       
        //$headers[] = &quot;Date: &quot;.gmdate(&quot;D, d M Y H:i:s&quot;, time()).&quot; GMT&quot;;

        $curl = curl_init();

        curl_setopt($curl, CURLOPT_USERAGENT,      'Syndication-Client/php-drupal v1'); // Useragent string to use for request
        curl_setopt($curl, CURLOPT_FOLLOWLOCATION, true );
        curl_setopt($curl, CURLOPT_RETURNTRANSFER, true );
        if ( $response_format=='image' )
        {
            curl_setopt($curl, CURLOPT_HEADER,         false );
            curl_setopt($curl, CURLOPT_BINARYTRANSFER, true  );
        }

        switch ( strtolower($http_method) )
        {
            case 'post':
                //curl_setopt( $curl, CURLOPT_POST,       true    );
                curl_setopt( $curl, CURLOPT_CUSTOMREQUEST, 'POST'    );
                curl_setopt( $curl, CURLOPT_POSTFIELDS,    $http_params );
                $headers[] = 'Content-length: '.strlen($http_params);
                break;
            case 'put':
                curl_setopt( $curl, CURLOPT_CUSTOMREQUEST, 'PUT'        );
                curl_setopt( $curl, CURLOPT_POSTFIELDS,    $http_params );
                $headers[] = 'Content-length: '.strlen($http_params);
                break;
            case 'delete':
                curl_setopt( $curl, CURLOPT_CUSTOMREQUEST, 'DELETE' );
                curl_setopt( $curl, CURLOPT_POSTFIELDS,    $http_params  );
                $headers[] = 'Content-length: '.strlen($http_params);
                break;
            case 'get':
            default:
                curl_setopt( $curl, CURLOPT_HTTPGET, true ); 
                $url .= (strpos($url,'?')===FALSE?'?':'&amp;') . $http_params;
                $headers[] = 'Content-length: 0';
                break;
        }
        curl_setopt( $curl, CURLOPT_HTTPHEADER,     $headers);

        curl_setopt( $curl, CURLOPT_VERBOSE, 1 );
        curl_setopt( $curl, CURLOPT_STDERR,  STDOUT );
        curl_setopt( $curl, CURLOPT_CONNECTTIMEOUT, 10 );                    // seconds attempting to connect
        curl_setopt( $curl, CURLOPT_TIMEOUT,        $this-&gt;api['timeout'] ); // seconds cURL allowed to execute
        /** /// forces new connections
        curl_setopt( $curl, CURLOPT_FORBID_REUSE,  true );
        curl_setopt( $curl, CURLOPT_FRESH_CONNECT, true );
        curl_setopt( $curl, CURLOPT_MAXCONNECTS,   1);
        /**/
        curl_setopt( $curl, CURLOPT_URL, $url );

        return $curl;
    }

    /**
     * Generate API Key. Use public/private keys to sign as hash for this request. Used by Syndication Service to verify authenticity of request.  
     * 
     * @param string $http_method http request method 
     * @param string $url url 
     * @param array $params query params 
     * @param array $headers http request headers 
     * 
     * @access public
     * @return string Api Key
     */
    function apiGenerateKey( $http_method, $url, $params, $headers )
    {
        /// need to figure out how key sharing works

      // ordered and scrubbed headers: date,content-type,content-length;
      $canonicalizedHeaders  = '';
      $desiredHeaders = array('date','content-type','content-length');
      $headerData = array();
      foreach ( $headers as $header )
      {
        $pos = strpos(':',$header);
        if ( $pos )
        {
          $name  = strtolower(trim(substr($header,0,$pos)));
          $value = substr($header,$pos+1);
          $headerData[$name] = trim($value);
          if ( in_array($name,$desiredHeaders) )
          {
            $canononicalizedHeaders = $name .':'. trim(str_replace(array('\n','\r'),' ',$value)).&quot;\n&quot;;
          } 
        }      
      }
      $canonicalizedHeaders = trim($canonicalizedHeaders);

      // just the clean url path
      $url_parts = $this-&gt;parseUrl($url);
      $canonicalizedResource = ( !empty($url_parts) &amp;&amp; !empty($url_parts['path']) ) ? trim($url_parts['path']) : ''; 
        
      /// md5 of the body
      $http_params   = http_build_query( $params, '', '&amp;' );
      $hashedData    = md5($http_params);

      // array of: date,content-type,http method;
      $requestData = array( 'date'         =&gt; isset($headerData['date'])         ? $headerData['date']         : '', 
                            'content-type' =&gt; isset($headerData['content-type']) ? $headerData['content-type'] : '', 
                            'method'       =&gt; strtoupper($http_method) ); 

      // put it all together
      $signingString = &quot;{$requestData['method']}\n&quot;.
                       &quot;{$hashedData}\n&quot;.
                       &quot;{$requestData['content-type']}\n&quot;.
                       &quot;{$requestData['date']}\n&quot;.
                       &quot;{$canonicalizedHeaders}\n&quot;.
                       &quot;{$canonicalizedResource}&quot;;

      /// grab keys 
      $sharedKey     = &quot;SHARED SECRET KEY&quot;;  
      $myPublicKey   = &quot;MY PUBLIC KEY&quot;;  
      
      /// hash up our thingy
      $computedHash  = base64_encode(hash_hmac('sha1', $signingString, $sharedKey, true ));

      /// share public key are our hash
      return &quot;{$myPublicKey}:{$computedHash}&quot;;
    }
}
</pre>
        <script type="text/javascript">
             SyntaxHighlighter.all();
             jQuery('.gutter div').each(function(key, data){
                jQuery(data).prepend('<a name="L'+jQuery(data).text()+'"/>');
             });
        </script>
    </body>
</html>